---
title: "Construct an a11ytable"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Construct an a11ytable}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#"
)
```

## Purpose

The purpose of this vignette is to demonstrate how to create an a11ytable-class object, which provides the basis for generating an Excel workbook (xlsx).

Two approaches to constructing an a11ytable-class object are described in this document:

1. Pass arguments directly to `new_a11ytable()`
1. Create a data.frame-class object for conversion to a11ytable-class with `as_a11ytable()`.

## Workbook nomenclature

An output _workbook_ contains _tabs_ that have _sheets_ in them. Each tab has a unique _tab title_.

Sheets can be one of four _types_ that dictate the layout and content of a given sheet:

* a _cover_ sheet (required) contains the title of the workbook and miscellaneous details about the workbook, the data it contains and its producers
* a _contents_ sheet (required) contains a table showing the contents of the workbook at a glance
* a _notes_ sheet (if applicable) contains a table with a lookup of the note codes and explanations
* one or more _tables_ sheets (required) that contain statistical tables

Sheets are composed of _elements_:

* a _sheet title_ to be displayed at the top of the sheet (user-provided)
* a count of the number of tables in the sheet (auto-generated sentence)
* a _source_ to explain where the data come from (auto-generated based on user input)
* a warning that the sheet contains notes (auto-generated based on the presence of notes)
* a _table_ that contains information as rows and columns and has a _table name_ (both are user-provided, latter should be unique per table)

The `new_a11ytable()` function takes these elements as arguments to build an a11ytable-class object for you. For example, you pass a vector of tab titles to the `tab_titles` argument and a list of data.frames to the `table` argument.

Alternatively, you can construct your own data.frame with columns for each of these elements and coerce it to a11ytable-class using `as_a11ytable()`.

## Example

To demonstrate with the 'mtcars' dataset:

1. Prepare a table of information for each sheet of the workbook
1. Create an a11ytables-class object by either:
    a. passing data (including the data.frames mentioned above) as arguments to `new_a11ytable()`
    a. building your own data.frame and coercing with `as_a11ytable()`

Of course, we start by attaching the {a11ytables} package. I'm going to use {tibble} to construct tables, but you could use base R functions.

```{r setup}
library(a11ytables)
library(tibble)
```

### 1. Prepare tables

Each a11ytable sheet contains a tidy dataframe of information. Let's prepare these first.

For sheet type 'cover' (required), the table should contain a row per subsection with columns for the title and body text of each subsection. This will be arranged in the final output as a single column, alternating from title to body, with appropriate styling.

```{r prep-cover-tbl}
library(tibble)

cover_df <- tribble(
  ~"Subsection title", ~"Subsection body",
  "Description", "The data was extracted from the 1974 Motor Trend US magazine, and comprises fuel consumption and 10 aspects of automobile design and performance for 32 automobiles (1973â€“74 models)",
  "Format", "A data frame with 32 observations on 11 (numeric) variables."
)

cover_df
```

For sheet type 'contents' (required), the table should have a row per workbook sheet with columns for the tab title and the sheet title.

```{r prep-contents-tbl}
contents_df <- tribble(
  ~"Sheet name", ~"Sheet title",
  "Notes", "Notes",
  "Table 1", "Motor Trend Car Road Tests"
)

contents_df
```

For sheet type 'notes' (not required if there aren't any notes), the table should have a row per note in your workbook, with columns for the note number and note text.

```{r prep-notes-tbl}
notes_df <- tribble(
  ~"Note number", ~"Note text",
  "[2]", "Where 0 is 'V-shaped' and 1 is 'straight'",
  "[1]", "Hocking [original transcriber]'s noncrucial coding of the Mazda's rotary engine as a straight six-cylinder engine and the Porsche's flat engine as a V engine, as well as the inclusion of the diesel Mercedes 240D, have been retained to enable direct comparisons to be made with previous analyses."
)

notes_df
```

For sheet type 'tables' (required), the table should have whatever rows and columns are in the statistical table being published. It should be a tidy, 'flat' table with one row of headers and no empty rows or columns. This is an example using the 'mtcars' dataset.

```{r prep-stats-tbl}
stats_df <- mtcars %>% rownames_to_column("car")
notes_cars <- c("Mazda RX4", "Mazda RX4 Wag", "Porsche 914-2", "Merc 240D")
stats_df[["Notes"]] <- ifelse(stats_df[["car"]] %in% notes_cars, "[2]", "")
names(stats_df)[8] <- "vs [1]"
head(stats_df)
```

### 2a. From new with `new_a11ytable()`

The first option for creating the a11ytable-class object is to create it 'from new' by passing arguments about sheet elements to the `new_a11ytable()` function.

```{r new-a11ytable}
content_new <- new_a11ytable(
  tab_titles = c("Cover", "Contents", "Notes", "Table 1"),
  sheet_types = c("cover", "contents", "notes", "tables"),
  sheet_titles = c(
    "The mtcars demo datset: 'Motor Trend Car Road Tests'",
    "Table of contents",
    "Notes",
    "Motor Trend Car Road Tests"
  ),
  sources = c(
    NA_character_,
    NA_character_,
    NA_character_, 
    "Motor Trend (1974)"
  ),
  table_names = c(
    "cover_sheet",
    "table_of_contents",
    "notes_table",
    "demographic_benchmarks"
  ),
  tables = list(
    cover_df,
    contents_df,
    notes_df,
    stats_df
  )
)
```

You can confirm the class with `is_a11ytable()`.

```{r new-a11ytable-2}
is_a11ytable(content_new)
```

Success.

### 2b. Coerce with `as_a11ytable()`

The second option is to create a data.frame with the appropriate variables and content and coerce it to a11ytable class with `as_a11ytable()` (a11ytable objects are just a type of data.frame with an additional class, after all).

Starting with a data.frame of your own construction is a more flexible way of creating an a11ytable, if you know what you're doing. There are validation checks within the function to catch anything that doesn't look right.

```{r as-a11ytable-df}
content_df <- tibble(
  tab_title = c("Cover", "Contents", "Notes", "Table 1"),
  sheet_type = c("cover", "contents", "notes", "tables"),
  sheet_title = c(
    "The mtcars demo dataset: 'Motor Trend Car Road Tests'",
    "Table of contents",
    "Notes",
    "Motor Trend Car Road Tests"
  ),
  source = c(
    NA_character_, NA_character_, NA_character_, 
    "Motor Trend (1974)"
  ),
  table_name = c(
    "cover_sheet",
    "table_of_contents",
    "notes_table",
    "demographic_benchmarks"
  ),
  table = list(
    cover_df,
    contents_df,
    notes_df,
    stats_df
  )
)
```

This data.frame object can be passed directly into the `as_a11ytable()` to add the a11ytable class, which again you can test with `is_a11ytable()`.

```{r as-a11ytable-2}
content_coerce <- as_a11ytable(content_df)
is_a11ytable(content_coerce)
```

Success.

## Next steps

Regardless of whether `new_a11ytable()` or `is_a11ytable()` was used, the a11ytable-class output can be passed to `new_a11y_wb()` to convert it to Workbook-class, before being written with `openxlsx::saveWorkbook()` or opened as a temporary file with `openxlsx::openXL()`. 
