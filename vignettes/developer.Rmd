---
title: "Theory"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{developer}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#"
)
```

# Purpose

This vignette explains the underlying philosophy of the package's code.

# Spreadsheets

Certain language and conventions are used in the package to talk about spreadsheets.

A _workbook_ contains _tabs_ that have _sheets_ in them. Each tab has a _tab title_.

Sheets can be one of four _sheet types_ that dictate the layout and content of a given sheet:

* a _cover_ sheet contains the title of the workbook and miscellaneous details about the workbook, the data it contains, and its producers
* a _contents_ sheet contains a table showing the contents of the workbook at a glance
* a _notes_ sheet contains a table with a lookup of the note codes and explanations
* one or more _tables_ sheets contain the statistical tables themselves, or annexes

The _cover_, _contents_ and _notes_ sheets can be considered _meta sheets_ because they provide contextual information about the _workbook_ and it's contents.

_Sheets_ themselves are composed of inserted _elements_ (in this order):

* a _sheet title_ to be displayed at the top of the sheet (user-provided)
* a _table count_ so users know how many tables are in the sheet (auto-generated)
* a _notes statement_ that declares if a table contains _notes_ (if applicable, auto-generated)
* a _blank cells statement_ that indicates the meaning behind any blank cells in a table (if applicable, user-provided)
* a _source statement_ to explain where the data came from (if applicable, user-provided)
* a _table_ that contains information as rows and columns (user-provided) and has a _table name_ (auto-generated)

# Functions

There are only two user facing functions: `new_a11ytable()` and `create_a11y_wb()`.

Unexported functions are prefixed with a period to make it clearer that they are internal functions.

## a11ytables

* S3 class.
* Basically `new_a11ytable()` creates a dataframe with an additional class, 'a11ytable', added. 
* The functions includes validity checks and passes warnings to the user about the construction of the a11ytable object
* `.validate_a11ytable(x)` errors if basic needs are not met, like if 'cover', 'contents' and 'notes' have been declared more than once in the sheet_type column
* `.warn_a11ytable(x)` checks for things that could be a problem, like if 5 notes are declared in the notes sheet but there are fewer in the tables themselves

## Workbook

* `create_a11y_wb()` sets up a Workbook-class object and fill it by iterating over the a11ytable-class object
* User sees `create_a11y_wb()` and needs only pass an a11ytable-class object to the 'a11ytable' argument.

### Add

* The `create_a11y_wb()` contains a series of `.add_*()` functions that add sheets, fill them with content and then style them
* These are `.add_tabs()`, which inserts the required tabs into the workbook; `.add_cover()` and `.add_contents()`, which run once each because there should only be one of each in the provided a11ytable; `.add_notes()` if a notes sheet exists; and `.add_table()` for each 'table' sheet_type in the a11ytable
* The main functions within the `.add_()` functions are the `.insert_*()` functions, which insert sheet elements to each sheet, and `style_*()`, which apply formatting to each sheet and the workbook overall

#### Insert

* The pre-table elements are `.insert_title()`, `.insert_table_count()`, `.insert_source()`, `.insert_notes_statement()` and `.insert_blanks_message()`; tables are added with `.insert_table()`
* The exact `.insert_*()` functions called depend on the sheet_type: meta sheets (cover, contents and notes) need only `.insert_title()` and `.insert_table_count()`; statistical tables also require `.insert_source()` and `.insert_blanks_message()` if provided, as well as `.insert_notes_statement()` if notes are detected in the table or there's a sheet_type of 'notes'
* The `.insert_*()` functions are applied in order so that the sheet title goes in cell A1 and the table-count statement ('there are x tables on this sheet') goes below it; for sheet_type table, there's then a statement about notes in the sheet, the statement about the meaning of blank cells and the data source (depending on whether these need to be inserted or not)
* The `.insert_*()` functions for note presence, meaning of blank cells, data source and tables also include simple logic for handling which cell to place them in; if all are inserted, then the table would begin in row 6 (i.e. after the sheet title, table count, note presence, meaning of blank cells and source), but it's possible that the table would have to be inserted to row 3 if only the sheet title and statement are required

#### Style

* `.style_create()` invokes a central list of styles created with `openxlsx::createStyle()`, which can be applied across different elements and sheets; you can create the style object like `styles <- .style_create()` and then `style$bold`, etc, for each style
* `.style_workbook()` applies font styles (Arial 12) at the level of the whole workbook
* The functions `.style_cover()`, `.style_contents()` and `.style_notes()` all apply specific styles to each sheet_type
* The functions `.style_sheet_title()`, `.style_table()` apply styles to particular elements; the title is larger and bolder than the default font and the table has styles associated with the headers, for example
